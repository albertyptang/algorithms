package io.github.albertyptang.algorithms.util.collection.array;

import io.github.albertyptang.algorithms.util.collection.linked.LinkedList;
import io.github.albertyptang.algorithms.util.collection.IList;

/**
 * @author atang
 */
public class HashTable<K,V> {

    /**
     * underlying data array.  the length will be considered the capacity.
     */
    private final TableArray<IList<Entry<K,V>>> tableArray = new TableArray<>();

    /**
     * table array.
     */
    private class TableArray<E extends IList<Entry<K,V>>> extends DynamicArray<E> {

        // rehash table during refill.
        @Override
        E[] refill(final E[] oldArray, final E[] newArray) {

            for(final E listOfEntries : oldArray) {
                if (listOfEntries != null) {
                    while (listOfEntries.length() > 0) {
                        final Entry<K,V> entry = listOfEntries.deleteHead();
                        put(entry.key, entry.value);
                    }
                }
            }
            return newArray;
        }
    }

    /**
     * key value entry.
     */
    private static class Entry<K,V> {

        private final K key;
        private V value;

        private Entry(final K key, final V value) {
            this.key = key;
            this.value = value;
        }

        // NOTE : equality is determined by the key only, not the value.
        @Override // auto-generated by IntelliJ
        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;

            final Entry<?, ?> entry = (Entry<?, ?>) o;

            return key != null ? key.equals(entry.key) : entry.key == null;
        }
    }

    /**
     * add an entry into the hash table.
     * O(1)
     * worst case O(n)
     */
    public void put(final K key, final V value) {
        final Entry<K,V> newEntry = new Entry<>(key, value);
        final int hash = hash(key);
        // entries already exist in hash bucket.
        if (tableArray.get(hash) != null) {
            final IList<Entry<K,V>> oldEntries = tableArray.get(hash);
            final Entry<K,V> foundEntry = oldEntries.searchFor(newEntry);
            if (foundEntry == null) {
                // entry doesn't exist, add to the end of the entries list.
                oldEntries.addToTail(newEntry);
            } else {
                // entry exists, update value.
                foundEntry.value = value;
                return;
            }
        } else {
            final IList<Entry<K,V>> newEntryList = new LinkedList<>();
            newEntryList.addToTail(newEntry);
            tableArray.set(hash, newEntryList);
        }
        tableArray.size++;
        if (tableArray.size > tableArray.length()) {
            // resize if necessary.
            tableArray.grow(tableArray.size);
        }
    }

    /**
     * @return value from the hash table or null if the key does not exist.
     */
    public V get(final K key) {
        try {
            return getOrThrow(key);
        } catch (Exception e) {
            return null;
        }
    }

    /**
     * @return whether the key exists in the hash table.
     */
    public boolean containsKey(final K key) {
        try {
            getOrThrow(key);
            return true;
        } catch (final Exception e) {
            return false;
        }
    }

    /**
     * hash key to fit into the data array.
     *
     * illustration:
     *
     *   101010 42 (default hash)
     * & 001111 15 (capacity - 1)
     * --------
     *   001010 10 (hash)
     */
    private int hash(final K key) {
        return key.hashCode() & (tableArray.length() - 1);
    }

    /**
     * get value from the hash table or throw an exception if the key does not exist.
     * O(1)
     * worst case O(n)
     * @return found value.
     */
    private V getOrThrow(final K key) throws Exception {
        final Entry<K,V> newEntry = new Entry<>(key, null);
        final int hash = hash(key);
        if (tableArray.get(hash) != null) {
            final IList<Entry<K,V>> entries = tableArray.get(hash);
            final Entry<K,V> foundEntry = entries.searchFor(newEntry);
            if (foundEntry != null) {
                return foundEntry.value;
            }
        }
        throw new Exception("Key does not exist in the hash table!");
    }
}
