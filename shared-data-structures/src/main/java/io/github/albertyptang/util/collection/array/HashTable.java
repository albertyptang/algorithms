package io.github.albertyptang.util.collection.array;

import io.github.albertyptang.util.collection.List;
import io.github.albertyptang.util.collection.linked.ListImpl;

/**
 * @author atang
 */
public class HashTable<K,V> {

    /**
     * underlying data array.  the length will be considered the capacity.
     */
    private DynamicArray<List<Entry<K,V>>> table = new DynamicArray<List<Entry<K,V>>>();

    /**
     * number of entries in the table.
     */
    public int size;

    /**
     * key value entry.
     */
    private static class Entry<K,V> {

        private final K key;
        private V value;

        private Entry(final K key, final V value) {
            this.key = key;
            this.value = value;
        }

        // NOTE : equality is determined by the key only, not the value.
        @Override // auto-generated by IntelliJ
        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;

            Entry<?, ?> entry = (Entry<?, ?>) o;

            return key != null ? key.equals(entry.key) : entry.key == null;
        }

        @Override // auto-generated by IntelliJ
        public int hashCode() {
            int result = key != null ? key.hashCode() : 0;
            result = 31 * result + (value != null ? value.hashCode() : 0);
            return result;
        }
    }

    /**
     * add an entry into the hash table.
     *
     * O(1)
     * worst case O(n)
     */
    public void put(final K key, final V value) {
        final Entry<K,V> newEntry = new Entry<K,V>(key, value);
        final int hash = hash(key);
        // entries already exist in hash bucket.
        if (table.get(hash) != null) {
            List<Entry<K,V>> oldEntries = table.get(hash);
            final Entry<K,V> foundEntry = oldEntries.search(newEntry);
            if (foundEntry == null) {
                // entry doesn't exist, add to the end of the entries list.
                oldEntries.append(newEntry);
            } else {
                // entry exists, update value.
                foundEntry.value = value;
                return;
            }
        } else {
            final List<Entry<K,V>> newEntryList = new ListImpl<Entry<K,V>>();
            newEntryList.append(newEntry);
            table.set(hash, newEntryList);
        }
        size++;
        if (size > table.length()) {
            // resize if necessary.
            grow(size);
        }
    }

    /**
     * get value from the hash table.
     *
     * O(1)
     * worst case O(n)
     */
    public V get(final K key) {
        final Entry<K,V> newEntry = new Entry<K,V>(key, null);
        final int hash = hash(key);
        if (table.get(hash) != null) {
            List<Entry<K,V>> entries = table.get(hash);
            final Entry<K,V> foundEntry = entries.search(newEntry);
            if (foundEntry != null) {
                return foundEntry.value;
            }
        } return null;
    }

    /**
     * grow underlying table for fewer collisions.
     */
    private void grow(final int necessaryCapacity) {

        if (necessaryCapacity > table.length()) {
            table.grow(necessaryCapacity);
            // rehash old entries.
            for (int i = 0; i < table.length(); i++) {
                final List<Entry<K,V>> listOfEntries = table.get(i);
                if (listOfEntries != null) {
                    while (listOfEntries.getSize() > 0) {
                        final Entry<K,V> entry = listOfEntries.deleteHead();
                        put(entry.key, entry.value);
                    }
                }
            }
        }
    }

    /**
     * hash key to fit into the data array.
     *
     * illustration:
     *
     *   101010 42 (default hash)
     * & 001111 15 (capacity - 1)
     * --------
     *   001010 10 (hash)
     */
    private int hash(final K key) {
        return key.hashCode() & (table.length() - 1);
    }
}
